#!/usr/bin/env bash


# setfile="env/set.sh"
# [[ -f "$setfile" ]] && source "$setfile"

if [ -z "$_dev" ]; then
  SUDO_FILE="$PWD/env/sudo.key"
fi

readonly DEPS="git bash curl"
readonly BOOTSTRAP_DIR="${BOOTSTRAP_DIR:-/tmp/bootstrap}"
readonly SUDO_FILE="${SUDO_FILE:-$BOOTSTRAP_DIR/sudo.key}"
readonly SUDO_FILE_TIMEOUT="2h"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly GH_URL="https://github.com/scottmonster/qyksys.git"

# Cleanup handler
cleanup(){
  # echo "timeout file is broken"
  timeout_script="$SCRIPT_DIR/bin/timeout_file.sh"
  if [ -f "$timeout_script" ]; then
    "$timeout_script" "$SUDO_FILE" "$SUDO_FILE_TIMEOUT" &
  fi
}
trap cleanup EXIT

# ensure sudo and install deps
preflight(){
  # ============================================================================
  # OS Detection & Package Mapping
  # ============================================================================

  get_os(){
    if [ -r /etc/os-release ]; then
      . /etc/os-release
      case "${ID:-}" in
        ubuntu|pop) printf "ubuntu"; return 0 ;;
        debian|raspbian|kali|parrot|dietpi|mx) printf "debian"; return 0 ;;
        fedora) printf "fedora"; return 0 ;;
        rhel|centos|rocky|almalinux) printf "redhat"; return 0 ;;
        arch|manjaro|endeavouros|garuda) printf "arch"; return 0 ;;
        opensuse*|sles) printf "suse"; return 0 ;;
        alpine) printf "alpine"; return 0 ;;
      esac
      case "${ID_LIKE:-}" in
        *ubuntu*) printf "ubuntu"; return 0 ;;
        *debian*) printf "debian"; return 0 ;;
        *rhel*|*fedora*) printf "redhat"; return 0 ;;
        *arch*) printf "arch"; return 0 ;;
        *suse*) printf "suse"; return 0 ;;
      esac
    fi

    case "$(uname -s)" in
      Darwin) printf "macos"; return 0 ;;
      Linux)
        if command -v apt-get >/dev/null 2>&1; then printf "debian"
        elif command -v dnf >/dev/null 2>&1; then printf "fedora"
        elif command -v pacman >/dev/null 2>&1; then printf "arch"
        elif command -v zypper >/dev/null 2>&1; then printf "suse"
        elif command -v apk >/dev/null 2>&1; then printf "alpine"
        else printf "linux"; fi
        ;;
      *) printf "unknown" ;;
    esac
  }

  get_install_cmd(){
    case "$(get_os)" in
      ubuntu|debian) printf "apt-get install -y" ;;
      fedora) printf "dnf install -y" ;;
      redhat) 
        if command -v dnf >/dev/null 2>&1; then printf "dnf install -y"
        else printf "yum install -y"; fi ;;
      arch) printf "pacman -S --noconfirm" ;;
      suse) printf "zypper install -y" ;;
      alpine) printf "apk add" ;;
      macos) printf "brew install" ;;
      *) return 1 ;;
    esac
  }

  get_os_package(){
    local generic_pkg="$1"
    local os
    os="$(get_os)"
    
    # Package name mappings for different distributions
    case "$generic_pkg" in
      python3)
        case "$os" in
          arch) printf "python" ;;
          *) printf "python3" ;;
        esac
        ;;
      ansible|git|bash)
        printf "%s" "$generic_pkg"
        ;;
      *)
        printf "%s" "$generic_pkg"
        ;;
    esac
  }

  get_sudo_group_name(){
    case "$(get_os)" in
      ubuntu|debian) printf "sudo" ;;
      fedora|redhat|arch|suse|alpine) printf "wheel" ;;
      macos) printf "admin" ;;
      *) printf "sudo" ;;
    esac
  }

  get_sudo_group_id(){
    case "$(get_os)" in
      ubuntu|debian) printf "27" ;;
      arch) printf "998" ;;
      fedora|redhat|suse|alpine) printf "10" ;;
      macos) printf "80" ;;
      *) printf "27" ;;
    esac
  }

  # ============================================================================
  # Utility Functions
  # ============================================================================

  is_root(){
    [ "$(id -u)" -eq 0 ]
  }

  is_installed(){
    command -v "$1" >/dev/null 2>&1
  }

  # ============================================================================
  # Sudo Configuration
  # ============================================================================

  add_user_to_group(){
    local user_to_add="$1"
    local group_name="$2"
    local group_id="$3"

    if [ "$(uname -s)" = "Darwin" ]; then
      if ! dscl . -read /Groups/"$group_name" >/dev/null 2>&1; then
        dseditgroup -o create -i "$group_id" "$group_name" 2>/dev/null || dseditgroup -o create "$group_name"
      fi
      if ! dsmemberutil checkmembership -U "$user_to_add" -G "$group_name" 2>/dev/null | grep -q "user is a member"; then
        dseditgroup -o edit -a "$user_to_add" -t user "$group_name"
      fi
    else
      if ! getent group "$group_name" >/dev/null 2>&1; then
        if ! getent group | grep -qE "^[^:]+:[^:]*:${group_id}:"; then
          groupadd -g "$group_id" "$group_name" 2>/dev/null || true
        else
          groupadd "$group_name" 2>/dev/null || true
        fi
      fi
      if ! getent group "$group_name" | grep -q "\b${user_to_add}\b"; then
        usermod -aG "$group_name" "$user_to_add"
      fi
    fi
  }

  ensure_sudo_usable(){
    local to_run=""
    
    if ! is_installed sudo; then
      echo "sudo is not installed"
      local install_cmd
      install_cmd=$(get_install_cmd) || { echo "ERROR: Unknown package manager" >&2; exit 1; }
      to_run="${install_cmd} sudo && "
    fi

    local sudo_group
    local sudo_gid
    sudo_group=$(get_sudo_group_name)
    sudo_gid=$(get_sudo_group_id)

    if ! id -nG "$USER" | tr ' ' '\n' | grep -Eqx 'sudo|wheel|admin'; then
      to_run="${to_run}$(declare -f add_user_to_group); add_user_to_group \"$USER\" \"$sudo_group\" \"$sudo_gid\""
    fi

    if [ -n "$to_run" ]; then
      echo "Configuring sudo access (requires root password)"
      su -l -c "bash -c '${to_run}'" root < /dev/tty || { echo "ERROR: Failed to configure sudo" >&2; exit 1; }
      
      if command -v sg >/dev/null 2>&1; then
        exec sg "$sudo_group" -c "$0 $*"
      else
        echo "Please log out and back in for group changes to take effect, then re-run this script."
        exit 0
      fi
    fi
    echo "sudo should be usable"
  }

  validate_sudo_secret(){
    [ -f "$SUDO_FILE" ] || return 1
    sudo -S -p '' -v <"$SUDO_FILE" 2>/dev/null
  }

  prompt_sudo_password(){
    local attempt=0
    local max_attempts=3
    local secret

    mkdir -p "$(dirname "$SUDO_FILE")"
    rm -f "$SUDO_FILE" 2>/dev/null || true

    while [ "$attempt" -lt "$max_attempts" ]; do
      attempt=$((attempt + 1))

      : >"$SUDO_FILE"
      chmod 600 "$SUDO_FILE"

      printf "[sudo] password for %s: " "$USER"
      stty -echo 2>/dev/null || true
      IFS= read -r secret || true
      stty echo 2>/dev/null || true
      printf "\n"

      printf "%s" "$secret" >"$SUDO_FILE"

      if validate_sudo_secret; then
        return 0
      else
        echo "Sorry, try again."
        rm -f "$SUDO_FILE"
        if [ "$attempt" -ge "$max_attempts" ]; then
          echo "ERROR: Too many incorrect attempts" >&2
          return 1
        fi
      fi
    done
    return 1
  }

  ensure_sudo_ready(){
    if is_root; then
      echo "script must not be run as root"
      exit 69
    fi

    echo "not running as root"

    ensure_sudo_usable

    sudo -k

    if [ -f "$SUDO_FILE" ] && validate_sudo_secret; then
      echo "existing sudo file $SUDO_FILE validated"
      return 0
    fi

    prompt_sudo_password || { echo "ERROR: Failed to validate sudo password" >&2; exit 1; }
  }

  # ============================================================================
  # Package Installation
  # ============================================================================

  check_and_install_packages(){
    local deps="$1"
    local to_install=()
    local pkg os_pkg

    # Check which packages need installation
    for pkg in $deps; do
      os_pkg=$(get_os_package "$pkg")
      if ! is_installed "$pkg"; then
        to_install+=("$os_pkg")
      fi
    done

    # Install if needed
    if [ "${#to_install[@]}" -gt 0 ]; then
      echo "Installing: ${to_install[*]}"
      local install_cmd
      install_cmd=$(get_install_cmd) || { echo "ERROR: Unknown package manager" >&2; exit 1; }
      
      # Update package cache for apt-based systems
      if [[ "$install_cmd" == apt-get* ]]; then
        if is_root; then
          apt-get update -qq
        else
          sudo -S sh -c "apt-get update -qq" <"$SUDO_FILE"
        fi
      fi

      # Install packages
      if is_root; then
        $install_cmd "${to_install[@]}"
      else
        sudo -S sh -c "$install_cmd ${to_install[*]}" <"$SUDO_FILE"
      fi
    fi
  }


  ensure_sudo_ready
  check_and_install_packages "$DEPS"
}

clone_repo(){

  not_git="$([[ -d .git ]] && echo 0 || echo 1)"
  not_scripts="$([[ -d scripts ]] && echo 0 || echo 1)"
  not_qyksys="$([[ $(basename "$PWD") == "qyksys" ]] && echo 0 || echo 1)"


  if ((not_git+not_scripts+not_qyksys)); then
    echo "cloning repo"
    git clone "$GH_URL"
    cd qyksys
    return 0
  else
    echo "i think we are already in the repo"
    return 1
  fi


}

gather_and_run_seeds(){
  if [[ $# -lt 1 ]]; then
    echo "no profile provided"
    echo "Usage: gather_and_run_seeds <profile>" >&2
    exit 2
  fi

  seeds="$(find "$PWD" -maxdepth 3 -type d -name seeds)"

  if [[ ! -d "$seeds" ]]; then
    echo "we need to panic exit becasue we don't know where to work"
    exit 1
  fi
  echo "seeds: $seeds"
  scripts_dir="$(dirname "$seeds")"
  layers="$scripts_dir/layers"
  profiles="$scripts_dir/profiles"

  target_profile="$profiles/${1}.conf"

  if [[ ! -f "$target_profile" ]]; then
    echo "we need to panic exit because profile $target_profile does not exist"
    exit 1
  fi




  target_seeds=()
  get_seed(){
    target="$1"

    source /etc/os-release

    VERSION_FULL="${DEBIAN_VERSION_FULL:-$VERSION_ID}"
    VERSION_MAJOR="${VERSION_FULL%%.*}"

    local V_IDS=($ID ${ID_LIKE:-})

    
    local seed_match=""
    for V_ID in "${V_IDS[@]}"; do 

      patterns=(
        "$target/"*"$V_ID"*"$VERSION_FULL"*
        "$target/"*"$VERSION_FULL"*"$V_ID"*
        "$target/"*"$V_ID"*"$VERSION_MAJOR"*
        "$target/"*"$VERSION_MAJOR"*"$V_ID"*
        "$target/"*"$V_ID"*
      )

      
      # ensure globs that don't match expand to empty
      shopt -s nullglob
      for pat in "${patterns[@]}"; do
        # expand pattern into an array of matches
        old_nullglob=$(shopt -p nullglob) 
        matches=( $pat )
        if (( ${#matches[@]} == 1 )); then
          # echo "${matches[0]}"
          seed_match="${matches[0]}"
          break # break the inner look as soon as we find a match
        fi
      done
      eval "$old_nullglob"
      [[ "$seed_match" != "" ]] && break # break the outer loop as soon as seed_match is set
    done

    if [[ -z "$seed_match" ]]; then
    
      echo "we should panic exit"
      exit 1
      return 1
    fi

    
    # the number of lines to search for the when line
    local l=5
    local when=""
    when="$(head -5 "$seed_match" | grep when: || true)"
    when="${when#*when:}"
    when="${when#"${when%%[![:space:]]*}"}" # ltrim
    when="${when%"${when##*[![:space:]]}"}" # rtrim


    if [[ "$when" == "" ]]; then
    local when_file="$target/when.sh"
      if [[ -f "$when_file" ]]; then
        # istrue expects scripts to be executable
        when="$when_file"
        [[ ! -x "$when" ]] && chmod +x "$when"
      else
        echo "[NO WHEN DECLARED] no when was declared for $seed_match" >&2
        exit 69
        return 69
      fi 
    fi
    
    local seed_name seed_file_name when_res
    seed_name="$(basename $(dirname "$seed_match"))"
    seed_file_name="$(basename "$seed_match")"

    # echo "$seed_name" >&2
    if istrue $when; then
      when_res="true"
      echo "$seed_match"
    else
      when_res="false"
    fi
    [[ -f "$when" ]] && when="$(basename "$when")"
    printf "==============\nseed name: %s\nseed_file: %s\nwhen: %s\nwhen_res: %s\n==============\n" "$seed_name" "$seed_file_name" "$when" "$when_res" >&2

  }

  target_seeds=()
  build_target_seeds() {
    local file="$1"
    local index=0

    while IFS= read -r line; do
      ((++index))
      # --- filter: strip inline comments & whitespace, skip blanks ---
      line="${line%%#*}"                                       # remove trailing comment
      line="${line#"${line%%[![:space:]]*}"}"                  # ltrim
      line="${line%"${line##*[![:space:]]}"}"                  # rtrim
      [[ -z $line ]] && continue                               # skip if empty after filtering
      # -------------------------------------------------------------
      if [ -f "$layers/${line}.conf" ]; then
        # shellcheck disable=SC1090
        build_target_seeds "$layers/${line}.conf"
        
      elif [ -d "$seeds/$line" ]; then
        seed="$(get_seed "$seeds/$line")" || exit $?

        if [[ "$seed" != "" ]] && [[ " ${target_seeds[@]} " != *" $seed "* ]]; then
          [[ ! -x "$seed" ]] && echo "get_seed returned non-executable: $seed" && exit 45
          echo "staging seed: $seed"
          target_seeds+=("$seed")
        fi

      else
        echo "panic: line: $index in file: $file - unknown target '$line' (neither $layers/$line nor $seeds/$line exist)" >&2
        exit 1
      fi

    done < "$file"

  }
  build_target_seeds "$target_profile"

  for seed in "${target_seeds[@]}"; do
    $seed
  done
}


main(){
  preflight
  echo "preflight complete"
  clone_repo
  if clone_repo; then
    # cd qyksys
    echo "yes we cloned the repo"
  fi
  echo "returned from clone_repo"
  echo "$PWD"
  export SUDO_CMD="$(command -v sudo)"
  export SUDO_FILE
  export PATH="$PWD/scripts/bin:$PWD/scripts/bin/caution:$PATH"
  gather_and_run_seeds upper


}

main "$@"
exit 0

cd $HOME   
[[ -d qyksys ]] && rm -rf qyksys
./share/qyksys/bootstrap
