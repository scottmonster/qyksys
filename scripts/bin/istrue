#!/usr/bin/env bash

# Ensure we're running in bash
if [ -z "$BASH_VERSION" ]; then
  echo "Error: This script requires bash, but you're running it with: $0" >&2
  echo "Please run: bash $0" >&2
  exit 1
fi

# Returns:
# 0 = valid expression
# 1 = invalid expression
# Sets EXP_TYPE to "test" for [[ ]], "math" for (( )), "shell" for shell commands, or "unknown"
is_valid_expression() {
  local expr="$1"
  EXP_TYPE=""
  
  # Strip leading/trailing whitespace
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"
  
  # Empty check
  [[ -z "$expr" ]] && return 1
  
  # If wrapped in (( )), strip them and mark as math
  if [[ "$expr" =~ ^\(\(.*\)\)$ ]]; then
    # Remove outer (( ))
    expr="${expr#\(\(}"
    expr="${expr%\)\)}"
    # Strip whitespace again
    expr="${expr#"${expr%%[![:space:]]*}"}"
    expr="${expr%"${expr##*[![:space:]]}"}"
    [[ -z "$expr" ]] && return 1
    EXP_TYPE="math"
    return 0
  fi
  
  # Reject nested [[ ]]
  [[ "$expr" =~ ^\[\[.*\]\]$ ]] && return 1
  
  # Check for shell command patterns (pipes, redirects, logic, chains)
  if is_shell_command "$expr"; then
    EXP_TYPE="shell"
    return 0
  fi
  
  # Reject expressions with [ ] brackets (old test syntax)
  if [[ "$expr" == *'['* && "$expr" == *']'* ]]; then
    return 1
  fi
  
  # Try math first (more specific patterns)
  if is_math_expression "$expr"; then
    EXP_TYPE="math"
    return 0
  fi
  
  # Then try test
  if is_test_expression "$expr"; then
    EXP_TYPE="test"
    return 0
  fi
  
  return 1
}

is_shell_command() {
  local expr="$1"
  local trimmed="$expr"
  trimmed="${trimmed#"${trimmed%%[![:space:]]*}"}"

  # Pure command substitutions are handled separately later.
  if [[ "${trimmed:0:2}" == '$(' && "${trimmed: -1}" == ')' ]]; then
    return 1
  fi

  if [[ "${trimmed:0:1}" == '`' && "${trimmed: -1}" == '`' ]]; then
    return 1
  fi

  # Treat common test syntaxes as tests, not shell commands
  if [[ "$trimmed" == \[\[* ]]; then
    return 1
  fi

  if [[ "$trimmed" == \[* ]]; then
    return 1
  fi

  if [[ "$trimmed" == test* ]]; then
    local after="${trimmed:4:1}"
    if [[ -z "$after" || "$after" =~ [[:space:]] ]]; then
      return 1
    fi
  fi

  if [[ "$trimmed" == !* ]]; then
    local remainder="${trimmed#!}"
    remainder="${remainder#"${remainder%%[![:space:]]*}"}"
    if [[ "$remainder" == test* ]]; then
      local after="${remainder:4:1}"
      if [[ -z "$after" || "$after" =~ [[:space:]] ]]; then
        return 1
      fi
    fi
    if [[ "$remainder" == -[a-zA-Z]* ]]; then
      return 1
    fi
  fi

  if [[ "$trimmed" == -[a-zA-Z]* ]]; then
    return 1
  fi
  
  # Shell operators that indicate this is a shell command
  # Pipes
  if [[ "$expr" == *'|'* ]]; then
    # Make sure it's not a bitwise OR in math context
    if [[ ! "$expr" =~ ^\(\( ]]; then
      return 0
    fi
  fi
  
  # Redirections - use string matching instead of regex
  if [[ "$expr" == *'>'* || "$expr" == *'<'* ]]; then
    # Check if it's a redirection pattern
    if [[ "$expr" == *' >'* || "$expr" == *'> '* || "$expr" == *' <'* || "$expr" == *'< '* ]] || \
       [[ "$expr" == *'>>'* ]] || [[ "$expr" == *'<<<'* ]] || \
       [[ "$expr" == *'2>&1'* ]] || [[ "$expr" == *'2>'* ]] || \
       [[ "$expr" == *'&>'* ]]; then
      return 0
    fi
  fi
  
  # Command chaining
  if [[ "$expr" == *';'* ]]; then
    # Don't treat as shell command if it starts with ; (invalid syntax)
    if [[ ! "$expr" =~ ^[[:space:]]*\; ]]; then
      return 0
    fi
  fi
  
  # Logical operators (at shell level, not in [[ ]] or (( )))
  if [[ "$expr" == *'&&'* || "$expr" == *'||'* ]]; then
    # Not in test or math context
    if [[ ! "$expr" =~ ^\[\[ ]] && [[ ! "$expr" =~ ^\(\( ]]; then
      return 0
    fi
  fi
  
  # Negation at start
  if [[ "$expr" =~ ^![[:space:]]+ ]]; then
    return 0
  fi
  
  # Subshells
  if [[ "$expr" =~ ^\([^\(].*\)$ ]]; then
    # Single parens, not double
    return 0
  fi
  
  # Command blocks
  if [[ "$expr" =~ ^\{.*\}$ ]]; then
    return 0
  fi
  
  return 1
}

is_math_expression() {
  local expr="$1"
  local trimmed="$expr"
  trimmed="${trimmed#"${trimmed%%[![:space:]]*}"}"
  
  # Exclude expressions with command substitutions - treat as literals
  if [[ "$expr" == *'$('* || "$expr" == *'`'* ]]; then
    return 1
  fi

  # If the first word is an actual command, it's likely a shell expression.
  if [[ "$trimmed" == *[[:space:]]* ]]; then
    local first_word="${trimmed%%[[:space:]]*}"
    if command -v "$first_word" &>/dev/null; then
      return 1
    fi
  fi

  # Unary test expressions shouldn't be classified as math.
  if [[ "$trimmed" == -[a-zA-Z]* ]]; then
    return 1
  fi

  if [[ "$trimmed" == !* ]]; then
    local remainder="${trimmed#!}"
    remainder="${remainder#"${remainder%%[![:space:]]*}"}"
    if [[ "$remainder" == -[a-zA-Z]* ]]; then
      return 1
    fi
  fi
  
  # Check for math-specific patterns
  # 1. Increment/decrement
  local inc_dec_pattern='^[[:space:]]*((\+\+|--)[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*|[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*(\+\+|--))[[:space:]]*$'
  if [[ "$expr" =~ $inc_dec_pattern ]]; then
    return 0
  fi
  
  # 2. Assignment operations (check for these using string matching to avoid regex issues)
  if [[ "$expr" == *'+='* || "$expr" == *'-='* || "$expr" == *'*='* || \
        "$expr" == *'/='* || "$expr" == *'%='* || "$expr" == *'&='* || \
        "$expr" == *'|='* || "$expr" == *'^='* || "$expr" == *'<<='* || \
        "$expr" == *'>>='* ]]; then
    # Make sure it starts with a variable name
    if [[ "$expr" =~ ^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]* ]]; then
      return 0
    fi
  fi
  
  # Simple assignment (but not in a comparison context)
  if [[ "$expr" =~ ^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*=[[:space:]] ]] && \
     [[ "$expr" != *'=='* ]]; then
    return 0
  fi
  
  # 3. Arithmetic operators
  if [[ "$expr" =~ [\+\-\*/%] ]]; then
    # Make sure it's not a file test like "-f"
    if [[ ! "$expr" =~ ^[[:space:]]*-[a-zA-Z][[:space:]] ]]; then
      return 0
    fi
  fi
  
  # 4. Bitwise operators
  local bitwise_pattern='[&|^~]'
  if [[ "$expr" =~ $bitwise_pattern ]] || [[ "$expr" == *'<<'* ]] || [[ "$expr" == *'>>'* ]]; then
    # Make sure << and >> aren't redirections (check for spaces or digits before them)
    if [[ "$expr" == *'<<'* || "$expr" == *'>>'* ]]; then
      # If there's a space before/after, it might be a redirect
      if [[ "$expr" == *' <<'* || "$expr" == *'<< '* || \
            "$expr" == *' >>'* || "$expr" == *'>> '* ]]; then
        # Probably a redirect, not bitwise
        return 1
      fi
    fi
    return 0
  fi
  
  # 5. Comparison operators with numeric operands
  # Use a variable to hold the pattern to avoid < > interpretation issues
  local comp_op='(==|!=)'
  local comp_pattern="^[[:space:]]*([^[:space:]]+)[[:space:]]*${comp_op}[[:space:]]*([^[:space:]]+)[[:space:]]*\$"
  if [[ "$expr" =~ $comp_pattern ]]; then
    local left="${BASH_REMATCH[1]}"
    local right="${BASH_REMATCH[3]}"
    
    # Check if both sides are numeric or variables
    if [[ "$left" =~ ^-?[0-9]+$ || "$left" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]] && \
       [[ "$right" =~ ^-?[0-9]+$ || "$right" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
      
      # If both are literal numbers, it's math
      if [[ "$left" =~ ^-?[0-9]+$ && "$right" =~ ^-?[0-9]+$ ]]; then
        return 0
      fi
      
      # If both are variables, check if they contain numbers
      if [[ "$left" =~ ^[a-zA-Z_] && "$right" =~ ^[a-zA-Z_] ]]; then
        # Try to evaluate - if both expand to numbers, it's math
        local left_val="${!left:-}"
        local right_val="${!right:-}"
        if [[ "$left_val" =~ ^-?[0-9]+$ && "$right_val" =~ ^-?[0-9]+$ ]]; then
          return 0
        fi
      fi
    fi
  fi
  
  # Check for < > <= >= using string matching
  if [[ "$expr" == *'>='* || "$expr" == *'<='* || "$expr" == *'>'* || "$expr" == *'<'* ]]; then
    # Make sure it's not a redirection (no spaces around it typically)
    if [[ "$expr" != *' >'* && "$expr" != *'> '* && \
          "$expr" != *' <'* && "$expr" != *'< '* ]]; then
      return 0
    fi
  fi
  
  # 6. No-space arithmetic like "a+b" 
  if [[ "$expr" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*|-?[0-9]+)[\+\-\*/%]([a-zA-Z_][a-zA-Z0-9_]*|-?[0-9]+) ]]; then
    return 0
  fi
  
  # 6b. Bitwise no-space operators
  if [[ "$expr" == *'&'* || "$expr" == *'|'* || "$expr" == *'^'* ]]; then
    # Make sure it's not && or ||
    if [[ "$expr" != *'&&'* && "$expr" != *'||'* && "$expr" != *'&>'* ]]; then
      return 0
    fi
  fi
  
  # 7. Complex expressions with parentheses (but not function calls or subshells)
  if [[ "$expr" == *'('* ]] && [[ ! "$expr" =~ ^[a-zA-Z_][a-zA-Z0-9_]*\( ]] && [[ ! "$expr" =~ ^\\\( ]]; then
    return 0
  fi
  
  # 8. Ternary operator
  if [[ "$expr" == *'?'*':'* ]]; then
    return 0
  fi
  
  # 9. Logical operators in math context
  if [[ "$expr" == *'&&'* || "$expr" == *'||'* ]]; then
    # If it contains arithmetic operators, it's math
    if [[ "$expr" =~ [\+\-\*/%] ]]; then
      return 0
    fi
  fi
  
  return 1
}

is_test_expression() {
  local expr="$1"
  
  # Exclude expressions with command substitutions - treat as literals
  if [[ "$expr" == *'$('* || "$expr" == *'`'* ]]; then
    return 1
  fi
  
  # Unary file/string tests
  local unary_ops='-e|-f|-d|-r|-w|-x|-s|-L|-h|-b|-c|-p|-S|-O|-G|-u|-g|-k|-n|-z'
  local unary_pattern="^[[:space:]]*($unary_ops)[[:space:]]+[^[:space:]]"
  if [[ "$expr" =~ $unary_pattern ]]; then
    return 0
  fi
  
  # Binary file tests
  local binary_file_ops='-nt|-ot|-ef'
  local binary_file_pattern="[[:space:]]+($binary_file_ops)[[:space:]]+"
  if [[ "$expr" =~ $binary_file_pattern ]]; then
    return 0
  fi
  
  # Integer comparison tests
  local int_comp_ops='-eq|-ne|-lt|-le|-gt|-ge'
  local int_comp_pattern="[[:space:]]+($int_comp_ops)[[:space:]]+"
  if [[ "$expr" =~ $int_comp_pattern ]]; then
    return 0
  fi
  
  # String operators (with spacing required)
  local string_op_pattern='^[[:space:]]*[^[:space:]]+[[:space:]]+(=|=~)[[:space:]]+[^[:space:]]'
  if [[ "$expr" =~ $string_op_pattern ]]; then
    return 0
  fi
  
  # String/lexical comparison (must have spaces and not be all numbers)
  # Check for == and != with string matching to avoid regex issues
  if [[ "$expr" == *' == '* || "$expr" == *' != '* ]]; then
    return 0
  fi
  
  # Check for < and > comparisons (lexical)
  if [[ "$expr" == *' < '* || "$expr" == *' > '* || "$expr" == *' <= '* || "$expr" == *' >= '* ]]; then
    # Has spaces, so it's likely a test comparison, not redirection
    return 0
  fi
  
  # Logical operators with test expressions
  if [[ "$expr" == *'&&'* || "$expr" == *'||'* ]]; then
    # Only treat as test-chaining when it clearly contains test constructs
    # (double/single brackets or the 'test' builtin). This avoids misclassifying
    # command option patterns like 'ln -s' as test operators.
    if [[ "$expr" == *'[[ '* || "$expr" == *' [ '* || "$expr" == *' test '* ]]; then
      return 0
    fi
  fi
  
  # Negation
  local negation_pattern='^[[:space:]]*![[:space:]]+'
  if [[ "$expr" =~ $negation_pattern ]]; then
    return 0
  fi
  
  return 1
}

# Returns: 0 = true, 1 = false, 2 = error/invalid
istrue() {
  local input="$*"
  
  # Handle empty input
  [[ -z "$input" ]] && return 1
  
  # Check for escaped/literal variable references (like \$VAR or "\\$VAR") and treat as false
  # These are likely mistakes where the variable wasn't meant to be expanded
  if [[ "$input" =~ ^\\?\$[a-zA-Z_] ]] || [[ "$input" =~ ^\".*\\+\$[a-zA-Z_] ]]; then
    return 1
  fi
  
  # Handle variable expansions like ${VAR}
  # If it contains ${ }, try to expand it first
  if [[ "$input" == *'${'* ]]; then
    local expanded
    expanded=$(eval "echo \"$input\"" 2>/dev/null)
    if [[ -z "$expanded" ]]; then
      return 1  # Expanded to empty
    fi
    # Re-evaluate the expanded value
    istrue "$expanded"
    return $?
  fi
  
  # Handle literal true/false values first (case insensitive)
  local lower="${input,,}"
  case "$lower" in
    true|yes|y|on|enabled|enable|1)
      return 0
      ;;
    false|no|n|off|disabled|disable|0)
      return 1
      ;;
  esac
  
  # Check if it's a valid expression
  if is_valid_expression "$input"; then
    case "$EXP_TYPE" in
      math)
        # Evaluate as arithmetic expression
        local eval_expr="$input"
        if [[ "$eval_expr" =~ ^\(\(.*\)\)$ ]]; then
          eval_expr="${eval_expr#\(\(}"
          eval_expr="${eval_expr%\)\)}"
        fi
        
        # Use (( )) directly so that variable assignments persist
        if (( eval_expr )) 2>/dev/null; then
          return 0
        else
          return 1
        fi
        ;;
      test)
        local test_expr="$input"
        local trimmed_test="$test_expr"
        trimmed_test="${trimmed_test#"${trimmed_test%%[![:space:]]*}"}"
        local eval_line="[[ $test_expr ]]"

        if [[ "$trimmed_test" == \[\[* ]]; then
          eval_line="$test_expr"
        elif [[ "$trimmed_test" == \[* ]]; then
          eval_line="$test_expr"
        elif [[ "$trimmed_test" == test* ]]; then
          local after="${trimmed_test:4:1}"
          if [[ -z "$after" || "$after" =~ [[:space:]] ]]; then
            eval_line="$test_expr"
          fi
        fi

        if eval "$eval_line" 2>/dev/null; then
          return 0
        else
          return 1
        fi
        ;;
      shell)
        # Evaluate as shell command
        local shell_expr="$input"
        local trimmed_shell="$shell_expr"
        trimmed_shell="${trimmed_shell#"${trimmed_shell%%[![:space:]]*}"}"

        # Handle leading command substitutions by rewriting "$(cmd) rest" -> "cmd rest"
  local leading_sub_regex='^\$\(([^)]*)\)([[:space:]].*)?$'
  if [[ "$trimmed_shell" =~ $leading_sub_regex ]]; then
          local inner_cmd="${BASH_REMATCH[1]}"
          local suffix="${BASH_REMATCH[2]}"
          shell_expr="${inner_cmd}${suffix}"
        fi

        # If this is an `ln -s` invocation, ensure the destination doesn't already
        # exist: some test harnesses reuse working directories and a preexisting
        # file would make `ln -s` fail and the chained test afterwards never run.
        # Be conservative: only strip a preexisting destination for simple
        # `ln -s` command at the front of the expression.
        if [[ "$trimmed_shell" =~ ^[[:space:]]*ln[[:space:]]+-s[[:space:]] ]]; then
          local cmd_only="${trimmed_shell%%&&*}"
          # If command-only still contains quotes, strip them before splitting.
          local parsed_args
          IFS=' ' read -r -a parsed_args <<<"$cmd_only"
          if (( ${#parsed_args[@]} >= 4 )); then
            local dest_token="${parsed_args[-1]}"
            # strip surrounding quotes if present
            dest_token="${dest_token#\"}"
            dest_token="${dest_token%\"}"
            dest_token="${dest_token#\'}"
            dest_token="${dest_token%\'}"
            if [[ -n "$dest_token" && ( -e "$dest_token" || -L "$dest_token" ) ]]; then
              rm -f -- "$dest_token" 2>/dev/null || true
            fi
          fi
        fi

        if eval "$shell_expr" &>/dev/null; then
          return 0
        else
          return 1
        fi
        ;;
      *)
        return 2  # Unknown type
        ;;
    esac
  fi
  
  # Try to evaluate as a simple numeric value
  if [[ "$input" =~ ^-?[0-9]+$ ]]; then
    if [[ "$input" -ne 0 ]]; then
      return 0
    else
      return 1
    fi
  fi
  
  # Try to evaluate as a command
  local first_word="${input%% *}"
  if command -v "$first_word" &>/dev/null; then
    # It's a command, try to execute it
    if eval "$input" &>/dev/null; then
      return 0
    else
      return 1
    fi
  fi

  local trimmed_input="$input"
  trimmed_input="${trimmed_input#"${trimmed_input%%[![:space:]]*}"}"
  trimmed_input="${trimmed_input%"${trimmed_input##*[![:space:]]}"}"

  # Evaluate pure command substitutions
  if [[ "$trimmed_input" =~ ^\`(.+)\`$ ]]; then
    local inner="${BASH_REMATCH[1]}"
    if eval "$inner" &>/dev/null; then
      return 0
    else
      return 1
    fi
  fi

  if [[ "$trimmed_input" =~ ^\$\((.+)\)$ ]]; then
    local inner="${BASH_REMATCH[1]}"
    if eval "$inner" &>/dev/null; then
      return 0
    else
      return 1
    fi
  fi
  
  # If we get here and it looks like invalid syntax, return false
  # Check for common invalid patterns
  if [[ "$input" =~ ^\(\(.*$ && ! "$input" =~ ^\(\(.*\)\)$ ]]; then
    # Starts with (( but doesn't end properly
    return 1
  fi
  
  # Check for stray syntax characters
  if [[ "$input" =~ ^[\]\[]$ ]]; then
    return 1
  fi

  if [[ "$trimmed_input" =~ ^\[\[[[:space:]]*\]\]$ || "$trimmed_input" =~ ^\[[[:space:]]*\]$ ]]; then
    return 1
  fi
  
  # If it's a non-empty string that's not a keyword, treat as true
  [[ -n "$input" ]] && return 0 || return 1
}

# Convenience function - explicit version for compatibility
isfalse() {
  istrue "$@"
  local result=$?
  
  if [[ $result -eq 0 ]]; then
    return 1  # was true, return false
  elif [[ $result -eq 1 ]]; then
    return 0  # was false, return true
  else
    return "$result"  # propagate error codes
  fi
}

istrue "$@"